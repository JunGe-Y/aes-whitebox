# AES-128 Whitebox

This code implements [Chow et al.](https://www.cs.colorado.edu/~jrblack/class/csci7000/s03/project/oorschot-whitebox.pdf) scheme, following [Muir's](https://eprint.iacr.org/2013/104.pdf) tutorial using protected L × MB bijections and XOR tables.

The tables generated by this program follow the _Chow et al._ proposition:

* 221,184 bytes for the XOR tables;
* 147,456 bytes for the Tyi-boxes tables using in rounds 1-9;
* 4,096 bytes for the T-boxes tables of round 10;
* 147,456 bytes for the inv(MB) × L tables.

Total: 520,192 bytes.

In order to build a full software 'oracle' based in the original paper, this code implements CFB, OFB and CTR block cipher modes of operation around the inner cipher.


## BGE Attack

The time complexity of [Billet et al.’s key extraction attack](https://link.springer.com/chapter/10.1007/978-3-540-30564-4_16) is less than 2^30, while [some further optimizations](https://eprint.iacr.org/2013/450.pdf) suggest 2^22.

So, care should be taken before using this implementation.


## How to use

- `aes128.cc`, `aes128.h` and `aes128_private.h` implement the standard AES-128 encryption, used only as an implementation reference and can be easily removed from the final build.
- `aes128_oracle_gen.cc` contains the AES-128 'compiler' (the tool that generates the WBC tables), that generates the `aes128_oracle_tables.cc` file that contains the cipher tables.
- `aes128_oracle.h` and `aes128_oracle.cc` contain the AES-128 implementation that consumes the `aes128_oracle_tables.cc`.

So for a final build, you must (1) compile the `aes128_oracle_gen` tool, (2) generate the `aes128_oracle_tables.cc` source file using it and add `aes128_oracle.h` together with `aes128_oracle.cc` to the final build.

The accompanying `Makefile` performs all steps in a single execution, including an unit test at the end.

The final API is just:

```
void aes128_oracle_encrypt_cfb(const uint8_t iv[16], const uint8_t* m, size_t len, uint8_t* c);
void aes128_oracle_decrypt_cfb(const uint8_t iv[16], const uint8_t* c, size_t len, uint8_t* m);

void aes128_oracle_encrypt_ofb(const uint8_t iv[16], const uint8_t* m, size_t len, uint8_t* c);
void aes128_oracle_decrypt_ofb(const uint8_t iv[16], const uint8_t* c, size_t len, uint8_t* m);

void aes128_oracle_encrypt_ctr(const uint8_t nonce[16], const uint8_t* m, size_t len, uint8_t* c);
void aes128_oracle_decrypt_ctr(const uint8_t nonce[16], const uint8_t* c, size_t len, uint8_t* m);
```

Where `iv` is the initialization vector, `m` is the message, `c` is the ciphertext and `len` is the number of bytes to encode/decode and can be of any size (does not have to be multiple of 16 bytes as required by other block cipher modes such as EBC and CBC).
